# Chapter 6: JavaScript and TypeScript: Part 2

## 6.1 Preparing the Example Project
## 6.2 Working with Objects

> Listing 6-1. - primer.ts
```javascript
let myData = new Object();
myData.name = "Peter";
myData.weather = "sunny";

console.log("Hello " + myData.name + ".");
console.log("Today is " + myData.weather + ".");
```

### 6.2.1 Using Object Literals

> Listing 6-2. - primer.ts
```javascript
let myData = {
  name: "Adam",
  weather: "sunny"
};

console.log("Hello " + myData.name + ". ");
console.log("Tday is " + myData.weather + ".");

```

### 6.2.2 Using Functions as Methods

> Listing 6-3. - primer.ts
```javascript
let myData = {
  name: "Adam",
  weather: "sunny",
  printMessages: function() {
    console.log("Hello " + myData.name + ". ");
    console.log("Tday is " + myData.weather + ".");
  }
};

myData.printMessages();

```

### 6.2.3 Defining Classes

Classes are templates that are used to create objects that have identical functionality. Support for classes is a recent addition to the JavaScript specification intended to make working with JavaScript more consistent with other mainstream programming languages, and they are used throughout Angular development. 

> Listing 6-4. - primer.ts
```javascript
class MyClass {
  constructor(name, weather) {
    this.name = name;
    this.weather = weather;
  }

  printMessages() {
    console.log("Hello " + this.name + ". ");
    console.log("Today is " + this.weather + ".");
  }
}

let myData = new MyClass("Peter", "sunny");
myData.printMessages();
```

#### 6.2.3.1 Defining Class Getter and Setter Properties
#### 6.2.3.2 Using Class Inheritance

> Listing 6-5. - primer.ts
```javascript
class MyClass {
  constructor(name, weather) {
    this.name = name;
    this._weather = weather;
  }

  set weather(value) {
    this._weather = value;
  }

  get weather() {
    return `Today is ${this._weather}`;
  }

  printMessages() {
    console.log("Hello " + this.name + ". ");
    console.log(this.weather);
  }
}

class MySubClass extends MyClass {
  constructor(name, weather, city) {
    super(name, weather);
    this.city = city;
  }

  printMessages() {
    super.printMessages();
    console.log(`You are in ${this.city}.`);
  }
}

let myData = new MySubClass("Peter", "napos", "Budapest");
myData.printMessages();

```

## 6.3 Working with JavaScript Modules

JavaScript modules are used to manage the dependencies in a web application, which means you don’t need to manage a set of script elements in the HTML document. Instead, a module loader is responsible for figuring out which files are required to run an application, loading those files and executing them in the right order. In a complex application, this is a difficult task to perform manually, and it is something that is well-suited to automation.

### 6.3.1 Creating Modules

Creating modules is simple and is performed automatically when  TypeScript compiles a file, because each file is treated as a module. The export keyword is used to denote variables and classes that can be used outside of the file, which means that any other variables or classes can be used only within the file.

> Listing 6-7. - modules/NameAndWeather.ts
```javascript
export class Name {
  constructor(first, second) {
    this.first = first;
    this.second = second;
  }

  get nameMessage() {
    return `Hello ${this.first} ${this.second}`;
  }
}

export class WeatherLocation {
  constructor(weather, city) {
    this.weather = weather;
    this.city = city;
  }

  getweatherMessage() {
    return `It is ${this.wheater} in ${this.city}`;
  }
}
```

### 6.3.2 Importing from JavaScript Modules

The <code>import</code> keyword is used to declare dependencies on the contents of a module.

### 6.3.2.1 Importing Specific Types 

> Listing 6-8. - primer.ts
```javascript
import { Name, WeatherLocation } from "./modules/NameAndWeather";

let name = new Name("Peter", "Csontos");
let loc = new WeatherLocation("sunny", "Budapest");

console.log(name.nameMessage);
console.log(loc.weatherMessage);
```

### 6.3.2.2 Renaming Imports

> Listing 6-9. - DuplicateName.ts
```javascript
class Name {
  get message() {
    return "Other Name";
  }
}
```
The solution is to use the <code>as</code> keyword, which allows an alias to be created for a class when it is important from a module, 

> Listing 6-10. - primer.ts
```javascript
import { Name, WeatherLocation } from "./modules/NameAndWeather";
import { Name as OtherName } from "./modules/DuplicateName";

let name = new Name("Peter", "Csontos");
let loc = new WeatherLocation("sunny", "Budapest");
let other = new OtherName();

console.log(name.nameMessage);
console.log(loc.weatherMessage);
console.log(other.message);
```

### 6.3.2.3 Importing All of the Types in a Module

> Listing 6-11. - primer.ts
```javascript
import * as NameAndWeatherLocation from "./modules/NameAndWeather";
import { Name as OtherName } from "./modules/DuplicateName";

let name = new NameAndWeatherLocation.Name("Peter", "Csontos");
let loc = new NameAndWeatherLocation.WeatherLocation("sunny", "Budapest");
let other = new OtherName();

console.log(name.nameMessage);
console.log(loc.weatherMessage);
console.log(other.message);

```

The <code>import</code> statement in this example imports the contents of the <code>NameAndWeather</code> module and creates an object called <code>NameAndWeatherLocation</code>. This object has <code>Name</code> and <code>Weather</code> properties that correspond to the classes defined in the module.

## 6.4 Useful TypeScript Features

http://www.typescriptlang.org/

### 6.4.1 Using Type Annotations

The flexibility of the JavaScript type system tends to polarize developers. For some developers, the fluidity of JavaScript types is powerful, expressive, and dynamic. For others, it is a recipe for chaos, to the extent that many developers are left with the impression that JavaScript doesn’t have a type system at all.

 Type annotations can go a long way to preventing the most common errors. On the other hand, if you like the freedom of regular JavaScript types, you may find TypeScript type annotations restrictive and annoying.

> Listing 6-12. - tempConverter.ts
```javascript
export class TempConverter {
  static convertFtoC(temp) {
    return ((parseFloat(temp.toPrecision(2)) - 32) / 1.8).toFixed(1);
  }
}
```

> Listing 6-13. - primer.ts
```javascript
import * as NameAndWeatherLocation from "./modules/NameAndWeather";
import { Name as OtherName } from "./modules/DuplicateName";
import { TempConverter } from "./tempConverter";

let name = new NameAndWeatherLocation.Name("Peter", "Csontos");
let loc = new NameAndWeatherLocation.WeatherLocation("sunny", "Budapest");
let other = new OtherName();

let cTemp = TempConverter.convertFtoC("38");

console.log(name.nameMessage);
console.log(loc.weatherMessage);
console.log(other.message);
console.log(`The temp is ${cTemp}C`);
```
ERROR

The TypeScript solution is to make type enforcement the job of the compiler, using type annotations that are added to the JavaScript code.


> Listing 6-14. - tempConverter.ts
```javascript
export class TempConverter {
  static convertFtoC(temp: number): string {
    return ((parseFloat(temp.toPrecision(2)) - 32) / 1.8).toFixed(1);
  }
}
```
#### 6.4.1.1 Type Annotating Properties and Variables
#### 6.4.1.2 Specifying Multiple Types or Any Type
### 6.4.2 Using Tuples
### 6.4.3 Using Indexable Types
### 6.4.4 Using Access Modifiers
## Summary