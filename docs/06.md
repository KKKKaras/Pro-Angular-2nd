# Chapter 6: JavaScript and TypeScript: Part 2

## 6.1 Preparing the Example Project
## 6.2 Working with Objects

> Listing 6-1. - primer.ts
```javascript
let myData = new Object();
myData.name = "Peter";
myData.weather = "sunny";

console.log("Hello " + myData.name + ".");
console.log("Today is " + myData.weather + ".");
```

### 6.2.1 Using Object Literals

> Listing 6-2. - primer.ts
```javascript
let myData = {
  name: "Adam",
  weather: "sunny"
};

console.log("Hello " + myData.name + ". ");
console.log("Tday is " + myData.weather + ".");

```

### 6.2.2 Using Functions as Methods

> Listing 6-3. - primer.ts
```javascript
let myData = {
  name: "Adam",
  weather: "sunny",
  printMessages: function() {
    console.log("Hello " + myData.name + ". ");
    console.log("Tday is " + myData.weather + ".");
  }
};

myData.printMessages();

```

### 6.2.3 Defining Classes

Classes are templates that are used to create objects that have identical functionality. Support for classes is a recent addition to the JavaScript specification intended to make working with JavaScript more consistent with other mainstream programming languages, and they are used throughout Angular development. 

> Listing 6-4. - primer.ts
```javascript
class MyClass {
  constructor(name, weather) {
    this.name = name;
    this.weather = weather;
  }

  printMessages() {
    console.log("Hello " + this.name + ". ");
    console.log("Today is " + this.weather + ".");
  }
}

let myData = new MyClass("Peter", "sunny");
myData.printMessages();
```

#### 6.2.3.1 Defining Class Getter and Setter Properties
#### 6.2.3.2 Using Class Inheritance

> Listing 6-5. - primer.ts
```javascript
class MyClass {
  constructor(name, weather) {
    this.name = name;
    this._weather = weather;
  }

  set weather(value) {
    this._weather = value;
  }

  get weather() {
    return `Today is ${this._weather}`;
  }

  printMessages() {
    console.log("Hello " + this.name + ". ");
    console.log(this.weather);
  }
}

class MySubClass extends MyClass {
  constructor(name, weather, city) {
    super(name, weather);
    this.city = city;
  }

  printMessages() {
    super.printMessages();
    console.log(`You are in ${this.city}.`);
  }
}

let myData = new MySubClass("Peter", "napos", "Budapest");
myData.printMessages();

```

## 6.3 Working with JavaScript Modules

JavaScript modules are used to manage the dependencies in a web application, which means you donâ€™t need to manage a set of script elements in the HTML document. Instead, a module loader is responsible for figuring out which files are required to run an application, loading those files and executing them in the right order. In a complex application, this is a difficult task to perform manually, and it is something that is well-suited to automation.

### 6.3.1 Creating Modules

Creating modules is simple and is performed automatically when  TypeScript compiles a file, because each file is treated as a module. The export keyword is used to denote variables and classes that can be used outside of the file, which means that any other variables or classes can be used only within the file.

> Listing 6-7. - modules/NameAndWeather.ts
```javascript
export class Name {
  constructor(first, second) {
    this.first = first;
    this.second = second;
  }

  get nameMessage() {
    return `Hello ${this.first} ${this.second}`;
  }
}

export class WeatherLocation {
  constructor(weather, city) {
    this.weather = weather;
    this.city = city;
  }

  getweatherMessage() {
    return `It is ${this.wheater} in ${this.city}`;
  }
}
```

### 6.3.2 Importing from JavaScript Modules

The <code>import</code> keyword is used to declare dependencies on the contents of a module.

### 6.3.2.1 Importing Specific Types 

> Listing 6-8. - primer.ts
```javascript
import { Name, WeatherLocation } from "./modules/NameAndWeather";

let name = new Name("Peter", "Csontos");
let loc = new WeatherLocation("sunny", "Budapest");

console.log(name.nameMessage);
console.log(loc.weatherMessage);
```

### 6.3.2.2 Renaming Imports

> Listing 6-9. - DuplicateName.ts
```javascript
class Name {
  get message() {
    return "Other Name";
  }
}
```
The solution is to use the <code>as</code> keyword, which allows an alias to be created for a class when it is important from a module, 

> Listing 6-10. - primer.ts
```javascript
import { Name, WeatherLocation } from "./modules/NameAndWeather";
import { Name as OtherName } from "./modules/DuplicateName";

let name = new Name("Peter", "Csontos");
let loc = new WeatherLocation("sunny", "Budapest");
let other = new OtherName();

console.log(name.nameMessage);
console.log(loc.weatherMessage);
console.log(other.message);
```

### 6.3.2.3 Importing All of the Types in a Module

> Listing 6-10. - primer.ts
```javascript
import * as NameAndWeatherLocation from "./modules/NameAndWeather";
import { Name as OtherName } from "./modules/DuplicateName";

let name = new NameAndWeatherLocation.Name("Peter", "Csontos");
let loc = new NameAndWeatherLocation.WeatherLocation("sunny", "Budapest");
let other = new OtherName();

console.log(name.nameMessage);
console.log(loc.weatherMessage);
console.log(other.message);

```

The <code>import</code> statement in this example imports the contents of the <code>NameAndWeather</code> module and creates an object called <code>NameAndWeatherLocation</code>. This object has <code>Name</code> and <code>Weather</code> properties that correspond to the classes defined in the module.



## 6.4 Useful TypeScript Features
### 6.4.1 Using Type Annotations
#### 6.4.1.1 Type Annotating Properties and Variables
#### 6.4.1.2 Specifying Multiple Types or Any Type
### 6.4.2 Using Tuples
### 6.4.3 Using Indexable Types
### 6.4.4 Using Access Modifiers
## Summary