# Chapter 2 - Your First Angular App

## [Preparing the Development Environment](#2.1)
### [Installing Node.js and NPM](#2.1.1)

Many of the tools used for Angular development rely on Node.js—also known as  node—which was created in 2009 as a simple and efficient runtime for server-side applications written in JavaScript. 

Node.js is:
  * **based** on the JavaScript engine used in the Chrome browser and 
  * **provides** an API for executing JavaScript code outside of the browser environment.

Node.js has provided the foundation for a new generation of cross-platform development and build tools. 

* Some <u>smart design decisions</u> by the Node.js team and
* the <u>cross-platform support</u> provided by the Chrome JavaScript runtime have created an opportunity that has been seized upon by enthusiastic tool writers. 
* has become an <u>essential tool</u> for web application development.

> [Console 2.1](#cli-2.1)
```
node -v
```

#### [Updating NPM](#2.1.1.1)

The success of Node.js has been helped by the **Node Package Manager (NPM)**, which provides easy access to an enormous catalog of development packages, including Angular. 

NPM takes care of:
* downloading packages and 
* managing the dependencies between them. 

NPM eases the process of keeping a project up-to-date.

### [Installing an Editor](#2.1.2)

* [Sublime Text](http://www.sublimetext.com)
* [Atom Atom](http://atom.io)
* [Brackets](http://brackets.io)
* [WebStorm](http://www.jetbrains.com/webstorm)
* [Visual Studio Code](http://code.visualstudio.com)

### [Installing a Browser](#2.1.3)

* Google Chrome
* Firefox
* Edge
* Opera
* Maxthon
* Internet Explorer
* stb.

## [Creating and Preparing the Project](#2.2)
### [Creating the Package File](#2.2.1)

NPM uses a file called package.json to get a list of the software packages that are required for a project.

> [Listing 2-1.](#listing_2.1) package.json

```json
{  
  "dependencies": {
    "@angular/common": "2.2.0",
    "@angular/compiler": "2.2.0",
    "@angular/core": "2.2.0",
    "@angular/forms": "2.2.0",
    "@angular/platform-browser": "2.2.0",
    "@angular/platform-browser-dynamic": "2.2.0",
    "reflect-metadata": "0.1.8",
    "rxjs": "5.0.0-beta.12",
    "zone.js": "0.6.26",
    "core-js": "2.4.1",
    "classlist.js": "1.1.20150312",
    "systemjs": "0.19.40",
    "bootstrap": "4.0.0-alpha.4"
  },
  "devDependencies": {
    "lite-server": "2.2.2",
    "typescript": "2.0.3",
    "typings": "1.4.0",
    "concurrently": "3.1.0"
  },
  "scripts": {
    "start": "concurrently \"npm run tscwatch\" \"npm run lite\" ",
    "tsc": "tsc",
    "tscwatch": "tsc -w",
    "lite": "lite-server",
    "typings": "typings"
  }
}
```

The <code>package.json</code> file lists the packages required to get started with Angular development and some
commands to use them.

### [2.2.2 - Installing the NPM Packages](#2.2.2)

> [Console 2.2](#cli-2.2)

```bash
npm install
npm list --depth 0
```

### [2.2.3 - Configuring the TypeScript Compiler](#2.3)

Angular applications are written in TypeScript, which is a superset of JavaScript. Working with TypeScript provides some useful advantages, but requires that TypeScript files are processed to generate *backward-compatible JavaScript* that can be used by browsers.

The TypeScript compiler requires a configuration file to control the kind of JavaScript files that it generates.

[>> Compiler Options: tsconfig.js](https://www.typescriptlang.org/docs/handbook/compiler-options.html)

> [Listing 2.2.](#listing_2.2) tsconfig.json

```json
{
  "compilerOptions": {
    "target": "es5",
    "module": "commonjs",
    "moduleResolution": "node",
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true
  },
  "exclude": ["node_modules"]
}
```

#### [2.2.3.4 - Installing the TypeScript Type Information](#2.3.4)

The TypeScript compiler relies on descriptions of the standard JavaScript APIs, known as type definitions, for the enhancements that TypeScript provides to the JavaScript language specification. The descriptions are still required to prevent the compiler reporting errors.

> [Console 2.3](#cli-2.3)

```bash
npm install --save --global @types/node
npm install --save --global @types/core-js
```

### [2.2.4 - Creating the HTML File](#2.2.4)

> [Listing 2.4.](#listing_2.4) index.html

```html
<!DOCTYPE html>
<html>
<head>
    <title>ToDo</title>
    <meta charset="utf-8" />
    <link href="node_modules/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet" />
</head>
<body class="m-a-1">
    <h1>Content will go here</h1>
</body>
</html>
```

### [2.2.5 - Starting the Server](#2.2.5)

> [Console 2.3](#cli-2.3)
```bash
npm start
```
### [2.2.6 - Replacing the HTML Content](#2.2.6)
> [Listing 2.5.](#listing_2.5) index.html

```html
...
<body class="m-a-1">
  <h3 class="bg-primary p-a-1">Adam's To Do List</h3>
  <div class="m-t-1 m-b-1">
    <input class="form-control" />
    <button class="btn btn-primary m-t-1">Add</button>
  </div>
  <table class="table table-striped table-bordered">
    <thead>
      <tr>
      <th>Description</th>
      <th>Done</th>
      </tr>
    </thead>
    <tbody>
      <tr><td>Buy Flowers</td><td>No</td></tr>
      <tr><td>Get Shoes</td><td>No</td></tr>
      <tr><td>Collect Tickets</td><td>Yes</td></tr>
      <tr><td>Call Joe</td><td>No</td></tr>
    </tbody>
  </table>
</body>
...
```
<code>lite-server</code> package is the development HTTP server I am using, adds a fragment of JavaScript to the HTML content it delivers to the browser. 

The JavaScript opens a connection back to the server and waits for a signal to reload the page, which is sent when the server detects a change in any of the files in the todo directory.

## [2.3 - Adding Angular to the Project](#2.3)

The static HTML in the <code>index.html</code> file acts as a placeholder for the basic application. 

### [2.3.1. - Preparing the HTML File](#2.3.1)

The new script elements add the JavaScript files for the Angular framework, and the third-party JavaScript libraries and polyfill that provide compatibility for older browsers. These files are all from the NPM packages.

```html
<head>
  ...
  <script src="node_modules/classlist.js/classList.min.js"></script>
  <script src="node_modules/core-js/client/shim.min.js"></script>
  <script src="node_modules/zone.js/dist/zone.min.js"></script>
  <script src="node_modules/reflect-metadata/Reflect.js"></script>
  <script src="node_modules/systemjs/dist/system.src.js"></script>
</head>

<body class="m-a-1">
<todo-app>Angular placeholder</todo-app>
</body>
</html>
```
### [2.3.2. - Creating a Data Model](#2.3.2)

The data from the way it is presented to the user is one of the key ideas in the MVC pattern.

Angular applications are typically written in TypeScript. TypeScript is a superscript of JavaScript, but one of its main advantages is that it lets you write code using the latest JavaScript language specification with features that are not yet supported in all of the browsers that can run Angular applications. One of the packages added to the project
in the previous section was the TypeScript compiler, which I set up to generate browser-friendly JavaScript.

> [Listing 2.7.](#listing_2.7) model.ts

```typescript
var model = {
  user: "Adam",
  items: [
      { action: "Buy Flowers", done: false },
      { action: "Get Shoes", done: false },
      { action: "Collect Tickets", done: true },
      { action: "Call Joe", done: false }
  ]
};
```

The most important aspect of using TypeScript: you don’t have to use the features it provides, and you can write entire Angular applications using just the JavaScript features that are supported by all browsers.

Part of the value of TypeScript is that it converts code that uses the latest JavaScript language features into code that will run anywhere, even in browsers that don’t support those features.

> [Listing 2.8.](#listing_2.8) model.ts
```typescript
export class Model {
  user;
  items;

  constructor() {
    this.user = "Adam";
    this.items = [
      new TodoItem("Buy Flowers", false),
      new TodoItem("Get Shoes", false),
      new TodoItem("Collect Tickets", false),
      new TodoItem("Call Joe", false)
    ];
  }
}

export class TodoItem {
  action;
  done;

  constructor(action, done) {
    this.action = action;
    this.done = done;
  }
}
```

The <code>class</code> keyword is used to define types that can be instantiated with the new keyword to create objects that have well-defined data and behavior.

Many of the features added in recent versions of the JavaScript language are syntactic sugar to help programmers avoid some of the most common JavaScript pitfalls, such as the unusual type system.

JavaScript type system, which is dynamic and expressive, but I find working with classes more predictable and less error-prone, and they simplify working with Angular, which has been designed around the latest JavaScript features.

The <code>export</code> keyword relates to JavaScript modules. When using modules, each TypeScript or JavaScript file is considered to be a self-contained unit of functionality, and the export keyword is used to identity data or types that you want to use elsewhere in the application. JavaScript modules are used to manage the
dependencies that arise between files in a project and avoid having to manually manage a complex set of script elements in the HTML file.

The TypeScript compiler processes the code to generate JavaScript code that uses only the subset of features that are widely supported by browsers.

### [2.3.3. - Creating a Template](#2.3.3)

I need a way to display the data values in the model to the user. In Angular, this is done using a **template**, which is a fragment of HTML that contains instructions that are performed by Angular.

> [Listing 2.9.](#listing_2.9) app.component.html

```html
<h3 class="bg-primary p-a-1">{{getName()}}-ek a tevékenység listája'</h3>
```
Including a data value in a template is done using double braces — {{ and }} — and Angular evaluates whatever you put between the double braces to get the value to display.

The {{ and }} characters are an example of a **data binding**, which means that they create a relationship between the template and a data value. Data bindings are an important Angular feature. The data binding tells Angular to invoke a function called <code>getName</code> and use the result as the contents of the <code>h3</code> element. The getName function doesn’t exist anywhere in the application at the moment, but I’ll create it in the next section.

### [2.3.4. - Creating a Component](#2.3.4)

An Angular **component** is responsible for managing a template and providing it with the data and logic it needs. They can be used for all sorts of tasks.

**A component act as the bridge between data model and template.**

> [Listing 2.10.](#listing_2.10) app.component.ts

```typescript
import { Component } from "@angular/core";
import { Model } from "./model";

@Component({
  selector: "todo-app",
  templateUrl: "app/app.component.html"
})
export class AppComponent {
  model = new Model();

  getName() {
    return this.model.user;
  }
}
```

#### [2.3.4.1 - Understanding the Imports](#2.3.4.1)

The import keyword is the counterpart to the export keyword and is used to declare a dependency on the contents of a JavaScript module.

```javascript
import { Component } from "@angular/core";
import { Model } from "./model";
```

<code>@angular/code</code> module contains the key Angular functionality, including support for components. The <code>import</code> statement specifies the types that are imported between curly braces.

#### [2.3.4.2 - Understanding the Decorator](#2.3.4.2)

https://angular.io/api/core/Component

```javascript
@Component({
  selector: "todo-app",
  templateUrl: "app/app.component.html"
})
```

The *decorator* provides metadata about a class. The decorator provides configuration information through its properties in this case <code>selector</code> and <code>templateUrl</code>.

The <code>selector</code> property specifies a CSS selector that matches the HTML element to which the component will be applied.

#### [2.3.4.3 - Understanding the Class](#2.3.4.3)

A class that Angular can instantiate to create the component.

```javascript
export class AppComponent {
  model = new Model();

  getName() {
    return this.model.user;
  }
}
```

### [2.3.5. - Putting the Application Together](#2.3.5)

The three key pieces of functionality required to build a simple Angular application: 

* a model,
* a template, and 
* a component. 

There are two types of module used in Angular development:
* *JavScript module* is a file that contains JavaScript functionality that is used through the <code>import</code> keyword.
* *Angular module* is used to describe an application or a group of related features. Every application has a root module, which provides Angular with the information that it needs to start the application. 


1. Create an Angular module.

> [Listing 2.11.](#listing_2.11) <code>app.module.ts</code>
```javascript
import { NgModule } from "@angular/core";
import { BrowserModule } from "@angular/platform-browser";
import { FormsModule } from "@angular/forms";
import { AppComponent } from "./app.component";

@NgModule({
  imports: [BrowserModule, FormsModule],
  declarations: [AppComponent],
  bootstrap: [AppComponent]
})
export class AppModule {}
```

The purpose of the Angular module is to provide configuration information through the properties defined by the <code>@NgModule</code> decorator.

The decorator’s <code>imports</code> property tells Angular that the application
depends on features required to run an application in the browser and that the <code>declarations</code> and <code>bootstrap</code> properties tell Angular about the components in the application and which one should be used to start the
application.

Angular applications also need a bootstrap file, which contains the code required to start the application and load the Angular module.

> [Listing 2.12.](#listing_2.12) <code>main.ts</code>
```javascript
import { platformBrowserDynamic } from "@angular/platform-browser-dynamic";
import { AppModule } from "./app.module";

platformBrowserDynamic().bootstrapModule(AppModule);
```


> [Listing 2.13.](#listing_2.13) <code>index.html</code>
```html
<script>
        var paths = {
            "rxjs/*": "node_modules/rxjs/bundles/Rx.min.js",
            "@angular/*": "node_modules/@angular/*"
        }
        var packages = {
            "app": {}
        };
        var angularModules = ["common", "compiler", "core", "forms",
            "platform-browser", "platform-browser-dynamic"
        ];
        angularModules.forEach(function (pkg) {
            packages["@angular/" + pkg] = {
                main: "/bundles/" + pkg + ".umd.min.js"
            };
        });
        System.config({
            paths: paths,
            packages: packages
        });
        System.import("app/main").catch(function (err) {
            console.error(err);
        });
    </script>
```

The <code>script</code> element in the listing configures the module loader.

### [2.3.6. - Running the Application](#2.3.6)

```bash
$ npm start
```

## [2.4 - Adding Features to the Example Application](#2.4)

### [2.4.1 - Adding the To-Do Table](#2.4.1)

> [Listing 2.14.](#listing_2.14) <code>app.components.ts</code>

```javascript
getTodoItems() {
    return this.model.items;
  }
```

> [Listing 2.15.](#listing_2.15) <code>app.component.html</code>
```html
<table class="table table-striped table-bordered">
    <thead>
        <tr>
            <th></th>
            <th>Description</th>
            <th>Done</th>
        </tr>
    </thead>
    <tbody>
        <tr *ngFor="let item of getTodoItems(); let i = index">
            <td>{{i+1}}</td>
            <td>{{item.action}}</td>
            <td [ngSwitch]="item.done">
                <span *ngSwitchCase="true">Yes</span>
                <span *ngSwitchDefault>No</span>
            </td>
        </tr>
    </tbody>
</table>
```

* <code>*ngFor</code> expression, which is used to repeat a region of content for each item in an array.
*  The <code>[ngSwitch]</code> expression is a conditional statement that is used to insert different sets of elements into the document based on a specified value, which is the item.done property in this case. 

### [2.4.2 - Creating a Two-Way Data Binding](#2.4.2)

The template contains only one-way data bindings, which means they are used to display a data value but do nothing to change it. Angular also supports two-way data bindings, which can be used to display a data value and update it.

> [Listing 2.16.](#listing_2.16) <code>app.component.html</code>
```html
<td>
   <input type="checkbox" [(ngModel)]="item.done" />
</td>
```

The <code>ngModel</code> template expression creates a two-way binding between a data value (the <code>item.done</code> property in this case) and a form element.

This reveals an important Angular feature, which is that the data model is *live*. The data bindings — even one-way data bindings — are updated when the data model is changed. This simplifies web application development because it means you don’t have to worry about ensuring that you display updates when the application state changes.

#### [2.4.2.1 - Filtering To-Do Items](#2.4.2.1)


> [Listing 2.17.](#listing_2.17) Filtering To-Do Items, <code>app.component.ts</code>

```javascript
 getTodoItems() {
    return this.model.items.filter(item => !item.done);
  }
```

### [2.4.3 - Adding To-Do Items](#2.4.3)

> [Listing 2.18.](#listing_2.18) <code>app.component.html</code>

```html
<div class="m-t-1 m-b-1">
    <input class="form-control" #todoText />
    <button class="btn btn-primary m-t-1" (click)="addItem(todoText.value)">
        Add
    </button>
</div>
```

> [Listing 2.19.](#listing_2.19) <code>app.component.ts</code>
```javascript
import { Model, TodoItem } from "./model";

...

addItem(newItem) {
    if (newItem != "") {
      this.model.items.push(new TodoItem(newItem, false));
    }
  }
```

## [2.5 - Summary](#2.5)

