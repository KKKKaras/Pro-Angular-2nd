# Chapter 5: JavaScript and TypeScript: Part 1

## 5.1 Preparing the Example Project

> Listing 5-1. - package.json

```json
{
  "name": "javascriptprimer",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "author": "",
  "license": "ISC",
  "dependencies": {
    "core-js": "2.4.1",
    "classlist.js": "1.1.20150312",
    "systemjs": "0.19.40",
    "bootstrap": "4.0.0-alpha.4"
  },
  "devDependencies": {
    "lite-server": "2.2.2",
    "typescript": "2.0.3",
    "typings": "1.4.0",
    "concurrently": "3.1.0"
  },
  "scripts": {
    "start": "concurrently \"npm run tscwatch\" \"npm run lite\" ",
    "tsc": "tsc",
    "tscwatch": "tsc -w",
    "lite": "lite-server",
    "typings": "typings"
  }
}
```

```bash
$ npm install
```

### 5.1.1 Creating the HTML and JavaScript Files

> Listing 5-2. - primer.ts
```javascript
console.log("Hello");
```

> Listing 5-3. - index.html
```html
<!DOCTYPE html>
<html>

<head>
    <title>Primer</title>
    <meta charset="utf-8" />
    <link href="node_modules/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet" />
    <script src="primer.js"></script>
</head>

<body class="m-a-1">
    <h3>JavaScript Primer</h3>
</body>

</html>
```

### 5.1.2 Configuring the TypeScript Compiler


> Listing 5-4. - tsconfig.json
```json
{
  "compilerOptions": {
    "target": "es5",
    "module": "commonjs",
    "moduleResolution": "node",
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true
  },
  "exclude": ["node_modules"]
}
```

### 5.1.3 Running the Example Project

```bash
$ npm start
```

## 5.2 Understanding the Script Element

```html
<script src="primer.js"></script>
```

### 5.2.1 Using a JavaScript Module Loader

Managing the JavaScript content in an application can be simplified by using a module loader, which takes responsibility for detecting and resolving dependencies between JavaScript files, loading them, and ensuring their contents are executed in the right order. The package.json file I created at the start of the chapter included the SystemJS module loader.

> Listing 5-5. - index.html

```html
<script src="node_modules/systemjs/dist/system.src.js"></script>
<script>
    System.config({
        packages: {
            "": {}
        }
    });
    System.import("primer").catch(function (err) {
        console.error(err);
    });
</script>
```

The last statement tells the module loader to load a module called <code>primer</code>, which is translated into a request for the <code>primer.js</code> file. One benefit of using the module loader is that you don’t have to pay attention to the file extensions in individual script elements.

### 5.2.2 Understanding the Basic Workflow

Getting used to the extra steps required in Angular development can take a while and the development workflow can feel indirect and cumbersome, but it does eventually become second nature, especially when the changes to the code files lead to the browser being automatically reloaded.

## 5.3 Using Statements

> Listing 5-7. - primer.ts
```javscript
console.log("This is a statement");
console.log("This is also a statement");
```

## 5.4 Defining and Using Functions

> Listing 5-8. - primer.ts
```javascript
let myFunc = function() {
  console.log("This is a statement");
};

myFunc();
```

### 5.4.1 Defining Functions with Parameters

> Listing 5-9. - primer.ts
```javascript
let myFunc = function(name, weather) {
  console.log("Hello " + name + ".");
  console.log("It is " + weather + " today");
};

myFunc("Adam", "sunny");
```

#### 5.4.1.1 Using Default and Rest Parameters

The number of arguments you provide when you invoke a function doesn’t need to match the number of parameters in the function. If you call the function with fewer arguments than it has parameters, then the value of any parameters you have not supplied values for is undefined, which is a special JavaScript value. If you call the function with more arguments than there are parameters, then the additional arguments are ignored.

*Polymorphism*  is supported in languages such as Java and C#, it isn’t available in JavaScript. Instead, if you define two functions with the same name, then the second definition replaces the first.

*Default parameters* deal with the situation where there are fewer arguments than parameters and allow you to provide a default value for the parameters for which there are no arguments.

### 5.4.1 Defining Functions with Parameters

> Listing 5-10. - primer.ts
```javascript
let myFunc = function(name, weather = "raining") {
  console.log("Hello " + name + ".");
  console.log("It is " + weather + " today");
};

myFunc("Adam", "sunny");
myFunc("Adam");
```

*Rest parameters* are used to capture any additional arguments when a function is invoked with additional arguments.

> Listing 5-11. - primer.ts
```javascript
let myFunc = function(name, weather = "raining", ...extraArgs) {
  console.log("Hello " + name + ".");
  console.log("It is " + weather + " today");
  for (let i = 0; i < extraArgs.length; i++) {
    console.log("Extra Arg: " + extraArgs[i]);
  }
};

myFunc("Adam", "sunny");
myFunc("Adam");
myFunc("Adam", "sunny", "one", "two", "three");

```

### 5.4.2 Defining Functions That Return Results

> Listing 5-12. - primer.ts
```javascript
let myFunc = function(name) {
  return "Hello " + name + ".";
};

console.log(myFunc("Adam"));
```

### 5.4.3 Using Functions as Arguments to Other Functions

> Listing 5-13. - primer.ts
```javascript
let myFunc = function(nameFunction) {
  return "Hello " + nameFunction() + ".";
};

console.log(
  myFunc(function() {
    return "Adam";
  })
);
```

> Listing 5-14. - primer.ts
```javascript
let myFunc = function(nameFunction) {
  return "Hello " + nameFunction() + ".";
};

let printName = function(nameFunction, printFunction) {
  printFunction(myFunc(nameFunction));
};

printName(function() {
  return "Adam";
}, console.log);
```

#### 5.4.3.1 Using Arrow Functions

> Listing 5-15. - primer.ts
```javascrip
let myFunc = nameFunction => "Hello " + nameFunction() + ".";

let printName = (nameFunction, printFunction) =>
  printFunction(myFunc(nameFunction));

printName(function() {
  return "Peter";
}, console.log);
```

## 5.5 Using Variables and Types

The <code>let</code> keyword is used to declare variables and, optionally, assign a value to the variable in a single statement. Variables declared with <code>let</code> are scoped to the region of code in which they are defined.

> Listing 5-16. - primer.ts
```javascrip
let messageFunction = function(name, weather) {
  let message = "Hello, Peter";
  if (weather == "sunny") {
    let message = "It is a nice day";
    console.log(message);
  } else {
    let message = "It is " + weather + " today";
    console.log(message);
  }
  console.log(message);
};

messageFunction("Peter", "raining");
```

> Listing 5-17. - primer.ts
```javascrip
let messageFunction = function(name, weather) {
  let message = "Hello, Peter";
  if (weather == "sunny") {
    let message = "It is a nice day";
    console.log(message);
  } else {
    let message = "It is " + weather + " today";
    console.log(message);
  }
  console.log(message);
};

let messageFunctionVar = function(name, weather) {
  var message = "Hello, Adam";
  if (weather == "sunny") {
    var message = "It is a nice day";
    console.log(message);
  } else {
    var message = "It is " + weather + " today";
    console.log(message);
  }
  console.log(message);
};

messageFunctionVar("Adam", "raining");

messageFunction("Peter", "raining");

```

USING VARIABLE CLOSURE

If you define a function inside another function — creating inner and outer functions — then the inner function is able to access the outer functions variables, using a feature called *closure*.

```javascript
let myGlobalVar = "apples";
let myFunc = function(name) {
  let myLocalVar = "sunny";
  let innerFunction = function() {
    return "Hello " + name + ". Today is " + myLocalVar + ".";
  };
  return innerFunction();
};

console.log(myFunc("Adam"));
```

The inner function in this example is able to access the local variables of the outer function, including its parameter. This is a powerful feature that means you don’t have to define parameters on inner functions to pass around data values, but caution is required because it is easy to get unexpected results when using common variable names like counter or index, where you may not realize that you are reusing a
variable name from the outer function.

### 5.5.1 Using the Primitive Types

JavaScript defines a basic set of primitive types: 
* string, 
* number, and 
* boolean. 

```javascript
let firstBool = true;
let secondBool = false;

// --
let firstString = "This is a string";
let secondString = "And so is this";

// --
let message = "It is " + "rainy" + " today";
let messageFunction = function(weather) {
  let message = `It is ${weather} today`;
  console.log(message);
};

messageFunction("raining");

// --
let daysInWeek = 7;
let pi = 3.14;
let hexValue = 0xffff;
```

## 5.6 Using JavaScript Operators
### 5.6.1 Using Conditional Statements
### 5.6.2 The Equality Operator vs. the Identity Operator
### 5.6.3 Explicitly Converting Types
#### 5.6.3.1 Converting Numbers to Strings
#### 5.6.3.2 Converting Strings to Numbers
## 5.7 Working with Arrays
### 5.7.1 Using an Array Literal
### 5.7.2 Reading and Modifying the Contents of an Array
### 5.7.3 Enumerating the Contents of an Array
### 5.7.4 Using the Built-in Array Methods
## 5.8 Summary